; encoder_period is a PIO program that measures the period between encoder ticks.
;
; Copyright (C) 2024 Brian LePage
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
; 3. The name of the author may not be used to endorse or promote products
;    derived from this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.program encoder_period
.origin 0

.define PUBLIC VERSION 100 
.define PUBLIC CYCLES_PER_COUNT 12

; This PIO program monitors the encoder inputs to measure the period
; between encoder pulses.  At the start of a period, a 31-bit counter is
; initialized to its maximum value (0x7FFFFFFF) and is decremented every 12 cycles
; until the start of the next period.  The period start/end is determined
; by the transition of the encoder signals from 10 -> 00 (Reverse) or 
; 01 -> 00 (Forward).

; Every period, the total count is passed to the robot code through the RX FIFO.
; The upper 31 bits is the count.  It represents the number of 12-cycle intervals
; that passed between encoder ticks.  This count will be off by one because
; it takes an additional 12 cycles to process the end of period.
; The LSB will indicate the direction (1 for forward, 0 for reverse).

; Robot code will calculate the count and direction as follows:
;      unsigned int rx_fifo = pio_sm_get_blocking(pio, sm);
;      bool direction = rx_fifo & 1;
;      unsigned int count = (rx_fifo >> 1) + 1;

; x register stores the current count (negated because it is counting down)
; y register stores the current direction (1 => forward, 0 => reverse)

; when reading encoder inputs, isr will get current state; previous state is saved to osr

; Current state jump table
jmp check_prev ; 00 Could be end of period; check previous state
jmp decr [6]   ; 01 Not end of period
jmp decr [6]   ; 10 Not end of period
jmp decr [6]   ; 11 Not ned of period

; Previous state jump table
jmp decr        ; 00 -> 00 Not end of period
jmp fwd_fin [4] ; 01 -> 00 End of period forward direction
jmp rev_fin [4] ; 10 -> 00 End of period reverse direction
jmp clear_x     ; 11 -> 00 This shouldn't happen, clear x register and let robot code sort it out...

check_prev:
   mov isr, ~null   ; Set all bits of ISR
   in osr, 2        ; Shift last state from OSR into ISR.  
                    ; Last 3 bits of isr will be 1xx, where xx is the previous state
   mov osr, isr     ; mov isr into osr for jump
   mov isr, null    ; restore current state (00) to isr
   out pc, 3        ; goto previous state jump table

decr:
   jmp x--, read    ; decrement counter
clear_x:
   set x, 0         ; don't go below 0, if at 0, motor is stopped.
read:
   mov osr, isr     ; save last state
   mov isr, null    ; clear ISR
   in pins, 2       ; shift in current state
   mov pc, isr      ; goto current state jump table

fwd_dirchanged:
   set y, 1 [2]      ;set current direction to fwd
   jmp clear_counter ;reset counter

rev_fin:
   jmp !y, send_period ;if direction did not change, send count
   set y, 0 [2]        ;set current direction to reverse
   jmp clear_counter   ;reset counter

fwd_fin:
   jmp !y, fwd_dirchanged ;if direction changed, set direction and reset count
send_period:
   mov isr, ~x         ;prepare counter to be sent to robot code
   in y, 1             ;append direction bit
   push noblock        ;send count to robot code
   mov isr, null       ;restore current state (00)
clear_counter:
   mov osr, ~null      ;set all bits in osr
   out x, 31           ;set 31 bits of x register        
   jmp decr

% c-sdk {
static inline void encoder_period_program_init(PIO pio, uint sm, uint offset, uint base_pin) {
    pio_sm_config c = encoder_period_program_get_default_config(offset);

    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_in_shift(&c, false, false, 32);
    sm_config_set_out_shift(&c, true, false, 32);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
